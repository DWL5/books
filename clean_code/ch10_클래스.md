### 클래스 체계
- 변수 목록
  - 정적 static, 공개 public 상수, 변수
  - 정적 static, 비공개 상수, 변수
  - 비공개 인스턴스 변수
  - 공개 함수
  - 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다.

### 클래스는 작아야 한다.
- 함수는 물리적인 행 수로 크기를 측정했다. 클래스는 다른 척도를 사용한다. 클래스가 맡은 책임을 센다.
- 클래스의 이름은 해당 클래스 책임을 기술해야 한다.
 - 클래스 이름이 모호하다면 필경 클래스 책임이 너무 많아서다.
 - Processor, Manager, Super등과 같이 모호한 단어가 있다면 클래스에다 여러 책임을 떠안겼다는 증거다.

### 단일 책임 원칙 (SRP)
- 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.
- 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.
- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.

### 응집도
- 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.
- 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문이다.
- 응집도를 유지하면 작은 클래스 여럿이 나온다
```
예를 들어, 변수가 아주 많은 큰 함수 하나가 있다. 
큰 함수 일부를 잦ㄱ은 함수 하나로 빼내고 싶은데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다. 
그렇다면 변수 네 개를 새 함수에 인수로 넘겨야 옳을까?

전혀 아니다! 만약 네 변수를 클래스 인스턴스 변수로 승격한다면 새 함수는 인수가 필요없다.
그만큼 함수를 쪼개기 쉬워진다.

불행히도 이렇게 하면 클래스가 응집력을 잃는다.
몇몇 함수만 사용하는 인스턴스 변수가 점점 더 늘어나기 때문이다.
그런데 잠깐만! 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리해도 되지 않는가?
클래스가 응집력을 잃는다면 쪼개라!
```

### 변경하기 쉬운 클래스
- SRP와 OCP를 만족하는 클래스
- OCP란 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙이다.

### 변경으로부터 격리
- 객체 지향 프로그래밍에서 우리는 구체적인 클래스와 추장 클래스가 있다고 배웠따.
- 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다.
- 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.

### 상세한 구현에 의존하는 코드는 테스트가 어렵다.
- 외부 API와 연동해야 하는 함수의 테스트는 어떻게 할 것인가
- 이 부분을 인터페이스로 분리해보자

```
public interface StockExchange {
  Money currentPrice(String symbol);
}
```

```
public Portfolio {
  private StockExchange exchange;
  public Portfolio(StockExchange exchange) {
    this.exchange = exchange;
  }
}

```
- 인터페이스를 호라용하여 시스템의 결합도를 낮추면 유연성과 재사용성이 높아진다.
- 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로 부터 그리고 변경으로부터 잘 격리되어 있다는 의미다.
- 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이애하기도 더 쉬워진다.

### DIP
- 이렇게 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP를 따르는 클래스가 나온다.
- 본질적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.
- 위의 StockExchange는 주식 기호를 받아 현재 주식 가격을 반환한다는 추상적인 개념이고, 이와 같은 추상화로 실제로 주가를 얻어오는 출처나 방식(구체적인 구현)을 숨길 수 있다.
